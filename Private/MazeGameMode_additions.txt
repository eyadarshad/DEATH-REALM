void AMazeGameMode::CompleteLevel()
{
    if (CurrentGameState != EGameState::Playing) return;
    
    CurrentGameState = EGameState::Won;
    
    // Calculate completion time
    LevelCompletionTime = TotalGameTime - RemainingTime;
    
    // Calculate stars
    StarsEarnedThisLevel = LevelManager->CalculateStarRating(CurrentLevel, LevelCompletionTime);
    
    // Record completion
    LevelManager->RecordLevelCompletion(CurrentLevel, LevelCompletionTime, StarsEarnedThisLevel);
    
    // Unlock next level
    if (CurrentLevel < 5)
    {
        LevelManager->UnlockLevel(CurrentLevel + 1);
    }
    
    UE_LOG(LogTemp, Warning, TEXT("[CompleteLevel] Level %d completed in %.2f seconds - %d stars!"), 
           CurrentLevel, LevelCompletionTime, StarsEarnedThisLevel);
    
    // Play win sound
    if (WinSound)
    {
        UGameplayStatics::PlaySound2D(GetWorld(), WinSound, 0.8f);
    }
    
    // Hide HUD
    if (HUDWidget)
    {
        HUDWidget->RemoveFromParent();
    }
    
    if (SpawnedMonster)
    {
        SpawnedMonster->StopChasing();
    }
    
    // Show completion message
    if (GEngine)
    {
        FString StarText = FString::Printf(TEXT("â­ %d STAR%s!"), StarsEarnedThisLevel, StarsEarnedThisLevel == 1 ? TEXT("") : TEXT("S"));
        GEngine->AddOnScreenDebugMessage(-1, 10.0f, FColor::Yellow,
            FString::Printf(TEXT("ðŸŽ‰ LEVEL %d COMPLETE! %s ðŸŽ‰"), CurrentLevel, *StarText));
    }
    
    // Wait 3 seconds then proceed
    FTimerHandle CompletionTimer;
    GetWorldTimerManager().SetTimer(CompletionTimer, [this]()
    {
        if (CurrentLevel == 5)
        {
            // Final level - return to main menu
            RestartGame();
        }
        else
        {
            // Advance to next level
            StartLevel(CurrentLevel + 1);
        }
    }, 3.0f, false);
}

void AMazeGameMode::ShowLevelSelectScreen()
{
    if (!LevelSelectWidgetClass)
    {
        UE_LOG(LogTemp, Error, TEXT("[ShowLevelSelectScreen] LevelSelectWidgetClass not set!"));
        return;
    }
    
    // Hide main menu
    if (MainMenuWidget)
    {
        MainMenuWidget->RemoveFromParent();
        MainMenuWidget = nullptr;
    }
    
    // Create and show level select
    ULevelSelectWidget* LevelSelect = CreateWidget<ULevelSelectWidget>(GetWorld(), LevelSelectWidgetClass);
    if (LevelSelect)
    {
        LevelSelect->AddToViewport(100);
        
        APlayerController* PC = UGameplayStatics::GetPlayerController(GetWorld(), 0);
        if (PC)
        {
            PC->bShowMouseCursor = true;
            PC->SetInputMode(FInputModeUIOnly());
        }
        
        UE_LOG(LogTemp, Warning, TEXT("[ShowLevelSelectScreen] Level select displayed"));
    }
}

void AMazeGameMode::LoadSelectedLevel(int32 LevelNumber)
{
    UE_LOG(LogTemp, Warning, TEXT("[LoadSelectedLevel] Loading Level %d"), LevelNumber);
    
    // Complete cleanup
    CleanupBeforeLevel();
    
    // Start the selected level
    StartLevel(LevelNumber);
}

void AMazeGameMode::CleanupBeforeLevel()
{
    UE_LOG(LogTemp, Warning, TEXT("[CleanupBeforeLevel] Cleaning up all entities..."));
    
    // Destroy all maze cells
    if (MazeManager)
    {
        for (auto& Row : MazeManager->MazeGrid)
        {
            for (AMazeCell* Cell : Row)
            {
                if (Cell)
                {
                    Cell->Destroy();
                }
            }
        }
        MazeManager->MazeGrid.Empty();
    }
    
    // Destroy monster
    if (SpawnedMonster)
    {
        SpawnedMonster->Destroy();
        SpawnedMonster = nullptr;
    }
    
    // Destroy star
    if (SpawnedStar)
    {
        SpawnedStar->Destroy();
        SpawnedStar = nullptr;
    }
    
    // Destroy muddy patches
    TArray<AActor*> MuddyPatches;
    UGameplayStatics::GetAllActorsOfClass(GetWorld(), AMuddyPatch::StaticClass(), MuddyPatches);
    for (AActor* Patch : MuddyPatches)
    {
        Patch->Destroy();
    }
    
    // Destroy safe zones
    if (SpawnedSafeZone)
    {
        SpawnedSafeZone->Destroy();
        SpawnedSafeZone = nullptr;
    }
    
    // Destroy flashlight
    if (PlayerFlashlight)
    {
        PlayerFlashlight->DestroyComponent();
        PlayerFlashlight = nullptr;
    }
    
    // Reset flags
    bMonsterSpawned = false;
    bMonsterSpeedBoosted = false;
    bMazeTrapTriggered = false;
    bPlayerTrapped = false;
    bMuddyEffectActive = false;
    bSafeZoneActive = false;
    
    // Reset player speed
    if (Player)
    {
        ACharacter* PlayerChar = Cast<ACharacter>(Player);
        if (PlayerChar && PlayerChar->GetCharacterMovement())
        {
            PlayerChar->GetCharacterMovement()->MaxWalkSpeed = 600.0f;
        }
    }
    
    // Reset resolution
    if (GEngine)
    {
        GEngine->Exec(GetWorld(), TEXT("r.ScreenPercentage 100"));
    }
    
    UE_LOG(LogTemp, Warning, TEXT("[CleanupBeforeLevel] âœ“ Cleanup complete"));
}

void AMazeGameMode::CreatePlayerFlashlight()
{
    if (!Player)
    {
        UE_LOG(LogTemp, Error, TEXT("[CreatePlayerFlashlight] No player!"));
        return;
    }
    
    PlayerFlashlight = NewObject<USpotLightComponent>(Player);
    if (PlayerFlashlight)
    {
        PlayerFlashlight->RegisterComponent();
        PlayerFlashlight->AttachToComponent(Player->GetRootComponent(), FAttachmentTransformRules::KeepRelativeTransform);
        
        PlayerFlashlight->SetIntensity(6000.0f);
        PlayerFlashlight->SetInnerConeAngle(25.0f);
        PlayerFlashlight->SetOuterConeAngle(50.0f);
        PlayerFlashlight->SetAttenuationRadius(2500.0f);
        PlayerFlashlight->SetLightColor(FLinearColor(1.0f, 0.95f, 0.85f));
        PlayerFlashlight->SetCastShadows(true);
        
        PlayerFlashlight->SetRelativeLocation(FVector(50.0f, 0.0f, 60.0f));
        PlayerFlashlight->SetRelativeRotation(FRotator(-15.0f, 0.0f, 0.0f));
        
        UE_LOG(LogTemp, Warning, TEXT("[CreatePlayerFlashlight] âœ“ Flashlight created"));
    }
}

void AMazeGameMode::SpawnSafeZone(float ActivationTime)
{
    if (!SafeZoneCellClass || !MazeManager)
    {
        UE_LOG(LogTemp, Warning, TEXT("[SpawnSafeZone] SafeZoneCellClass not set!"));
        return;
    }
    
    // Find random cell (not escape cell)
    AMazeCell* SafeCell = nullptr;
    int32 Attempts = 0;
    do {
        SafeCell = MazeManager->GetRandomCell();
        Attempts++;
    } while (SafeCell && SafeCell->bIsEscapeCell && Attempts < 100);
    
    if (SafeCell)
    {
        FVector SpawnLoc = SafeCell->GetActorLocation();
        SpawnLoc.Z = 50.0f;
        
        FActorSpawnParameters Params;
        Params.SpawnCollisionHandlingOverride = ESpawnActorCollisionHandlingMethod::AlwaysSpawn;
        
        SpawnedSafeZone = GetWorld()->SpawnActor<ASafeZoneCell>(SafeZoneCellClass, SpawnLoc, FRotator::ZeroRotator, Params);
        
        if (SpawnedSafeZone)
        {
            bSafeZoneActive = true;
            SafeZoneActivationTime = ActivationTime;
            UE_LOG(LogTemp, Warning, TEXT("[SpawnSafeZone] âœ“ Safe zone spawned"));
        }
    }
}

void AMazeGameMode::CheckSafeZoneStatus()
{
    if (!Player || !SpawnedSafeZone) return;
    
    FVector PlayerLoc = Player->GetActorLocation();
    FVector SafeZoneLoc = SpawnedSafeZone->GetActorLocation();
    float Distance = FVector::Dist2D(PlayerLoc, SafeZoneLoc);
    
    if (Distance < 300.0f)
    {
        // Player is safe!
        UE_LOG(LogTemp, Warning, TEXT("[SafeZone] âœ“ Player is in safe zone!"));
        if (GEngine)
        {
            GEngine->AddOnScreenDebugMessage(-1, 5.0f, FColor::Green, TEXT("âœ“ SAFE! Maze regenerating..."));
        }
        
        // Regenerate maze without trapping
        TriggerMazeTrap();
    }
    else
    {
        // Player is NOT safe - trap them!
        UE_LOG(LogTemp, Warning, TEXT("[SafeZone] âœ— Player NOT in safe zone - TRAPPED!"));
        AMazeCell* PlayerCell = GetPlayerCurrentCell();
        if (PlayerCell)
        {
            TrapPlayer(PlayerCell);
        }
    }
}

void AMazeGameMode::SpawnMuddyPatches(int32 Count)
{
    if (!MuddyPatchClass || !MazeManager)
    {
        UE_LOG(LogTemp, Warning, TEXT("[SpawnMuddyPatches] MuddyPatchClass not set!"));
        return;
    }
    
    for (int32 i = 0; i < Count; i++)
    {
        AMazeCell* PatchCell = MazeManager->GetRandomCell();
        if (PatchCell && !PatchCell->bIsEscapeCell)
        {
            FVector SpawnLoc = PatchCell->GetActorLocation();
            SpawnLoc.Z = 10.0f;
            
            FActorSpawnParameters Params;
            Params.SpawnCollisionHandlingOverride = ESpawnActorCollisionHandlingMethod::AlwaysSpawn;
            
            AMuddyPatch* Patch = GetWorld()->SpawnActor<AMuddyPatch>(MuddyPatchClass, SpawnLoc, FRotator::ZeroRotator, Params);
            if (Patch)
            {
                UE_LOG(LogTemp, Warning, TEXT("[SpawnMuddyPatches] âœ“ Muddy patch %d spawned"), i + 1);
            }
        }
    }
}
